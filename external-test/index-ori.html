<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Realtime Speech Translator (browser)</title>
</head>
<body>
  <h1>Realtime Speech Translator</h1>
  <p>
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
  </p>
  <p>Status: <span id="status">idle</span></p>
  <pre id="transcript"></pre>

<script>
const WS_URL = "ws://localhost:8000/ws";
const SAMPLE_RATE = 24000; // must match server/OpenAI

let ws;
let audioContext = null; // global
let processor;
let sourceNode;
let isRecording = false;
let stream;

const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const status = document.getElementById("status");
const transcriptEl = document.getElementById("transcript");

// Convert Float32 [-1..1] to Int16 PCM
function floatTo16BitPCM(float32Array) {
  const l = float32Array.length;
  const buffer = new Int16Array(l);
  for (let i = 0; i < l; i++) {
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    // scale to int16 range
    buffer[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
  }
  return buffer;
}

// Resample float32 array from inputSampleRate -> targetSampleRate using simple linear interpolation
function resampleBuffer(buffer, inputSampleRate, targetSampleRate) {
  if (inputSampleRate === targetSampleRate) {
    return buffer;
  }
  const ratio = inputSampleRate / targetSampleRate;
  const newLength = Math.round(buffer.length / ratio);
  const result = new Float32Array(newLength);
  let offsetResult = 0;
  let offsetBuffer = 0;
  while (offsetResult < newLength) {
    const nextOffsetBuffer = offsetResult * ratio;
    const before = Math.floor(nextOffsetBuffer);
    const after = Math.min(Math.ceil(nextOffsetBuffer), buffer.length - 1);
    const atPoint = nextOffsetBuffer - before;
    result[offsetResult] = (1 - atPoint) * buffer[before] + atPoint * buffer[after];
    offsetResult++;
  }
  return result;
}

function int16ToBase64(int16Array) {
  // convert to bytes
  const bytes = new Uint8Array(int16Array.buffer);
  let binary = "";
  const chunk = 0x8000;
  for (let i = 0; i < bytes.length; i += chunk) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
  }
  return btoa(binary);
}

function base64ToInt16(base64) {
  const binary = atob(base64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return new Int16Array(bytes.buffer);
}

async function startRecording() {
  try {
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch (err) {
    alert("Microphone access denied: " + err);
    return;
  }

  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const inputSampleRate = audioContext.sampleRate;
  sourceNode = audioContext.createMediaStreamSource(stream);

  // Using ScriptProcessor for ease of implementation (deprecated but broadly supported).
  const bufferSize = 2048;
  processor = audioContext.createScriptProcessor(bufferSize, 1, 1);
  sourceNode.connect(processor);
  processor.connect(audioContext.destination); // necessary in some browsers

  // open websocket
  ws = new WebSocket(WS_URL);
  ws.binaryType = "arraybuffer";

  ws.onopen = () => {
    status.textContent = "connected";
    // send config first
    ws.send(JSON.stringify({
      type: "config",
      voice: "echo",
      source_lang: "English",
      target_lang: "French"
    }));
    status.textContent = "sending audio";
  };

  ws.onmessage = (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      if (msg.type === "transcription.delta") {
        transcriptEl.textContent += msg.text;
      } else if (msg.type === "audio" && msg.audio) {
        // receive base64 Int16 PCM audio from server, play it.
        playInt16Base64Audio(msg.audio);
      } else if (msg.type === "response.done") {
        transcriptEl.textContent += "\n--- turn done ---\n";
      } else if (msg.type === "event") {
        console.log("event:", msg);
      }
    } catch (e) {
      console.error("ws message parse error", e);
    }
  };

  ws.onclose = () => {
    status.textContent = "ws closed";
  };

  ws.onerror = (e) => {
    console.error("ws error", e);
    status.textContent = "ws error";
  };

  // onaudioprocess: capture audio frames, resample, convert to Int16, base64 -> send
  processor.onaudioprocess = (evt) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;

    const channelData = evt.inputBuffer.getChannelData(0); // Float32Array
    // resample if needed
    const float32 = (audioContext.sampleRate === SAMPLE_RATE) ? channelData : resampleBuffer(channelData, audioContext.sampleRate, SAMPLE_RATE);
    const int16 = floatTo16BitPCM(float32);
    const base64 = int16ToBase64(int16);
    // send small chunks
    ws.send(JSON.stringify({ type: "input_audio", audio: base64 }));
  };

  isRecording = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  status.textContent = "recording";
}

function stopRecording() {
  if (processor) {
    processor.disconnect();
    processor.onaudioprocess = null;
  }
  if (sourceNode) sourceNode.disconnect();
  if (audioContext) audioContext.close();
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
  }
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.close();
  }
  isRecording = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  status.textContent = "stopped";
}




let audioQueue = Promise.resolve();  // queue promise to chain playback

function playInt16Base64Audio(base64Data) {
    const int16 = base64ToInt16(base64Data);
    const float32 = new Float32Array(int16.length);
    for (let i = 0; i < int16.length; i++) {
        float32[i] = int16[i] / 32768.0;
    }

    const buffer = audioContext.createBuffer(1, float32.length, SAMPLE_RATE);
    buffer.copyToChannel(float32, 0, 0);

    const src = audioContext.createBufferSource();
    src.buffer = buffer;
    src.connect(audioContext.destination);

    // chain audio chunks sequentially
    audioQueue = audioQueue.then(() => new Promise(resolve => {
        src.onended = resolve;
        src.start();
    }));
}



startBtn.addEventListener("click", () => startRecording());
stopBtn.addEventListener("click", () => stopRecording());
</script>
</body>
</html>
